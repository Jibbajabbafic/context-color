#!/bin/sh
#
# context-color
# Copyright (C) 2018, 2019 Guillaume Gelin
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

readonly PROGNAME=$(basename "$0")
readonly DEFAULT_CONTEXT="whoami; hostname"
readonly DEFAULT_EXCLUDES="0,7,15"

__context_color_usage() {
    cat <<- EOF
usage: $PROGNAME [OPTIONS]

Print a color sequence based on a command output's hash.

COMMON OPTIONS:
    --help, -h          Print this help.
    --background, -b    Use a background sequence rather than foreground.
    --prompt, -p        Declare the sequence as non-printable for prompts.

    --context <command>, -c <command>
                        Define the context command on which result the color
                        will be generated.
                        The default context is "$DEFAULT_CONTEXT".

    --exclude <colors>, -e <colors>
                        Comma separated list of color ids not to be used.
                        Multiple --exclude/-e arguments can be specified.
                        The default excluded colors are: "$DEFAULT_EXCLUDES"

DEBUG OPTIONS:
    --debug, -d         Output the sequence as a human-readable string and more
                        useful information.
    --force <color>, -f Ignore the context and force a color id instead.
EOF
}

__context_color_debug() {
    sequence="$(__context_color_sequence)"
    cat <<- EOF
Setup:
    Background mode: ${CC_BACKGROUND}
    Prompt mode: ${CC_PROMPT}
    Context command: ${CC_CONTEXT}
    Excluded colors: ${CC_EXCLUDES}
    Forced color: ${CC_FORCE_COLOR}

Colors:
    Terminfo: $(__context_color_terminfo_count)
    Excluded: $(__context_color_excludes_count)
    Included: $(__context_color_count)

Execution:
    Context hash: $(__context_color_hash)
    Choosen color: $(__context_color_id)

Output: ${sequence}$(echo "$sequence" | cat -v)$(tput sgr0)
EOF
}

__context_color_terminfo_count() {
    hexcount=$(infocmp -1 | sed -n -e 's/^\t*colors#\([0-9]x\?[0-9]*\),.*/\1/p')
    printf "%d" "$hexcount"
}

__context_color_excludes_count() {
    echo "$CC_EXCLUDES" | tr "," '\n' | wc -l
}

__context_color_count(){
    echo $(( $(__context_color_terminfo_count) - $(__context_color_excludes_count) ))
}

__context_color_hash() {
    hash=$(eval "$CC_CONTEXT" | sum | cut -d' ' -f1)
    echo "obase=10; $hash" | bc
}

__context_color_id() {
    if [ -n "$CC_FORCE_COLOR" ]
    then
        id="$CC_FORCE_COLOR"
    else
        id=$(( $(__context_color_hash) % ($(__context_color_count) - 1) ))
    fi

    for excluded_id in $(echo "$EXCLUDES" | tr ", " '\n')
    do
        if [ "$id" -ge "$excluded_id" ]
        then
            id=$((id + 1))
        fi
    done
    echo "$id"
}

__context_color_sequence() {
    if [ -n "$CC_BACKGROUND" ]
    then
        capname="setab"
    else
        capname="setaf"
    fi

    sequence="$(tput $capname "$(__context_color_id)")"

    if [ -n "$CC_PROMPT" ]
    then
        sequence="\\[${sequence}\\]"
    fi
    printf "%s" "$sequence"
}

context_color() {
    for arg
    do
        case "$arg" in
            --help)
                args="${args}-h "
                ;;
            --background)
                args="${args}-b "
                ;;
            --prompt)
                args="${args}-p "
                ;;
            --context)
                args="${args}-c "
                ;;
            --debug)
                args="${args}-d "
                ;;
            --force)
                args="${args}-f "
                ;;
            --exclude)
                args="${args}-e "
                ;;
            *)
                args="$args \"$arg\" "
                ;;
        esac
    done

    eval set -- "$args"

    while getopts "hbpc:e:df:" OPTION
    do
         case $OPTION in
         h)
             __context_color_usage
             exit 0
             ;;
         b)
             readonly CC_BACKGROUND=1
             ;;
         p)
             readonly CC_PROMPT=1
             ;;
         c)
             CC_CONTEXT="$OPTARG"
             ;;
         e)
             for arg in $(echo "$OPTARG" | tr "," '\n')
             do
                 if ! { [ "$arg" -le "$(__context_color_terminfo_count)" ] &&
                            [ "$arg" -ge "0" ]; } 2> /dev/null
                 then
                     >&2 echo "Invalid color id: $arg"
                     return 1
                 fi

                 if [ -z "$CC_EXCLUDES" ]
                 then
                     CC_EXCLUDES="$arg"
                 elif ! (echo "$CC_EXCLUDES" | tr ", " '\n' | grep -qw "$arg")
                 then
                     CC_EXCLUDES="$CC_EXCLUDES, $arg"
                 fi
             done
             ;;
         d)
             readonly CC_DEBUG=1
             ;;
         f)
             readonly CC_FORCE_COLOR="$OPTARG"
             ;;
         *)
             __context_color_usage
             exit 1
         esac
    done

    if [ -z "$CC_CONTEXT" ]
    then
        CC_CONTEXT="$DEFAULT_CONTEXT"
    fi
    if [ -z "$CC_EXCLUDES" ]
    then
        CC_EXCLUDES="$DEFAULT_EXCLUDES"
    fi

    if [ -n "$CC_DEBUG" ]
    then
        __context_color_debug
    else
        __context_color_sequence
    fi
    return 0
}

context_color "$@"
